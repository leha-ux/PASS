{"remainingRequest":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/babel-loader/lib/index.js!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/src/components/SBDflowchart/Flowchart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/src/components/SBDflowchart/Flowchart.vue","mtime":1655112394031},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/babel.config.js","mtime":1654095143863},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js","mtime":1655376985815},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/babel-loader/lib/index.js","mtime":1655376985883},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js","mtime":1655376985815},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/vue-loader/lib/index.js","mtime":1655376986005}],"contextDependencies":[],"result":["import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport _typeof from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/typeof.js\";\nimport \"core-js/modules/es6.math.hypot\";\nimport \"core-js/modules/es6.array.find\";\nimport _toConsumableArray from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.math.trunc\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es6.number.constructor\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { connect, lineTo } from \"@/utils/svg\";\nimport * as d3 from \"d3\";\nimport { between, distanceOfPointToLine, getEdgeOfPoints, pointRectangleIntersection } from \"@/utils/math\";\nimport render from \"./render\";\nimport renderMessage from \"./renderMessage\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { mapState } from 'vuex';\nexport default {\n  name: \"flowchart\",\n  props: {\n    idSBD: {\n      type: String\n    },\n    width: {\n      type: [String, Number],\n      default: 1000\n    },\n    height: {\n      type: [String, Number],\n      default: 1000\n    },\n    readonly: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function data() {\n    return {\n      connectingInfo: {\n        source: null,\n        sourcePosition: null\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: {\n        x: 0,\n        y: 0\n      },\n      clickedOnce: false,\n      pathClickedOnce: false,\n\n      /**\n       * lines of all connections\n       */\n      lines: []\n    };\n  },\n  methods: {\n    add: function add(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.nodes.push(node);\n      this.$emit(\"add\", node, this.nodes, this.connections);\n    },\n    editCurrent: function editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode: function editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editnode\", node);\n    },\n    editConnection: function editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel: function handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (event.ctrlKey) {\n        var svg = document.getElementById(\"svg\");\n        var zoom = parseFloat(svg.style.zoom || 1);\n\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    handleChartMouseUp: function () {\n      var _handleChartMouseUp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var tempId, conn;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.connectingInfo.source) {\n                  if (this.hoveredConnector) {\n                    if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n                      // Node can't connect to itself\n                      tempId = uuidv4();\n                      conn = {\n                        source: {\n                          id: this.connectingInfo.source.id,\n                          position: this.connectingInfo.sourcePosition,\n                          type: this.connectingInfo.source.type\n                        },\n                        destination: {\n                          id: this.hoveredConnector.node.id,\n                          position: this.hoveredConnector.position\n                        },\n                        id: tempId,\n                        messages: []\n                      };\n\n                      if (this.connectingInfo.source.type === \"send\") {\n                        conn[\"sendTo\"] = \"\";\n                        conn[\"sendMsg\"] = \"\";\n                        conn[\"messages\"] = [\"To:\", \"Msg:\"];\n                      } else if (this.connectingInfo.source.type === \"receive\") {\n                        conn[\"receiveFrom\"] = \"\";\n                        conn[\"receiveMsg\"] = \"\";\n                        conn[\"messages\"] = [\"From:\", \"Msg:\"];\n                      } else if (this.connectingInfo.source.type === \"action\") {\n                        conn[\"actionMsg\"] = \"\";\n                      }\n\n                      this.connections.push(conn);\n                      this.$emit(\"connect\", conn, this.nodes, this.connections);\n                    }\n                  }\n\n                  this.connectingInfo.source = null;\n                  this.connectingInfo.sourcePosition = null;\n                }\n\n                if (this.selectionInfo) {\n                  this.selectionInfo = null;\n                }\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleChartMouseUp() {\n        return _handleChartMouseUp.apply(this, arguments);\n      }\n\n      return handleChartMouseUp;\n    }(),\n    handleChartMouseMove: function () {\n      var _handleChartMouseMove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(event) {\n        var boundingClientRect, actualX, actualY, _iterator, _step, element, sourceOffset, destinationPosition, result;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // calc offset of cursor to chart\n                boundingClientRect = event.currentTarget.getBoundingClientRect();\n                actualX = event.pageX - boundingClientRect.left - window.scrollX;\n                this.cursorToChartOffset.x = Math.trunc(actualX);\n                actualY = event.pageY - boundingClientRect.top - window.scrollY;\n                this.cursorToChartOffset.y = Math.trunc(actualY);\n\n                if (!this.connectingInfo.source) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                _context2.next = 8;\n                return this.renderConnections();\n\n              case 8:\n                _iterator = _createForOfIteratorHelper(document.querySelectorAll(\"#svg .connector\"));\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    element = _step.value;\n                    element.classList.add(\"active\");\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                sourceOffset = this.getNodeConnectorOffset(this.connectingInfo.source.id, this.connectingInfo.sourcePosition);\n                destinationPosition = this.hoveredConnector ? this.hoveredConnector.position : null;\n                result = this.arrowTo(sourceOffset.x, sourceOffset.y, this.cursorToChartOffset.x, this.cursorToChartOffset.y, this.connectingInfo.sourcePosition, destinationPosition);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function handleChartMouseMove(_x) {\n        return _handleChartMouseMove.apply(this, arguments);\n      }\n\n      return handleChartMouseMove;\n    }(),\n    handleChartDblClick: function handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"dblclick\", {\n        x: event.offsetX,\n        y: event.offsetY\n      });\n    },\n    handleChartMouseDown: function handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n\n      this.selectionInfo = {\n        x: event.offsetX,\n        y: event.offsetY\n      };\n    },\n    getConnectorPosition: function getConnectorPosition(node) {\n      var halfWidth = node.width / 2;\n      var halfHeight = node.height / 2;\n      var top = {\n        x: node.x + halfWidth,\n        y: node.y\n      };\n      var left = {\n        x: node.x,\n        y: node.y + halfHeight\n      };\n      var bottom = {\n        x: node.x + halfWidth,\n        y: node.y + node.height\n      };\n      var right = {\n        x: node.x + node.width,\n        y: node.y + halfHeight\n      };\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    },\n    renderSelection: function renderSelection() {\n      var that = this; // render selection rectangle\n\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        var edge = getEdgeOfPoints([{\n          x: that.selectionInfo.x,\n          y: that.selectionInfo.y\n        }, {\n          x: that.cursorToChartOffset.x,\n          y: that.cursorToChartOffset.y\n        }]);\n\n        var _iterator2 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg .selection\")),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var rect = _step2.value;\n            rect.classList.add(\"active\");\n            rect.setAttribute(\"x\", edge.start.x);\n            rect.setAttribute(\"y\", edge.start.y);\n            rect.setAttribute(\"width\", edge.end.x - edge.start.x);\n            rect.setAttribute(\"height\", edge.end.y - edge.start.y);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        that.nodes.forEach(function (item) {\n          var points = [{\n            x: item.x,\n            y: item.y\n          }, {\n            x: item.x,\n            y: item.y + item.height\n          }, {\n            x: item.x + item.width,\n            y: item.y\n          }, {\n            x: item.x + item.width,\n            y: item.y + item.height\n          }];\n\n          if (points.some(function (point) {\n            return pointRectangleIntersection(point, edge);\n          })) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach(function (line) {\n          var points = [{\n            x: line.sourceX,\n            y: line.sourceY\n          }, {\n            x: line.destinationX,\n            y: line.destinationY\n          }];\n\n          if (points.every(function (point) {\n            return pointRectangleIntersection(point, edge);\n          }) && that.currentConnections.every(function (item) {\n            return item.id !== line.id;\n          })) {\n            var connection = that.connections.filter(function (conn) {\n              return conn.id === line.id;\n            })[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > .selection\")),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var element = _step3.value;\n            element.classList.remove(\"active\");\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    },\n    renderConnections: function renderConnections() {\n      var that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          var _iterator4 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.connection\")),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var element = _step4.value;\n              element.remove();\n            } // render lines\n\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          that.lines = [];\n\n          var _iterator5 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.sendMessage\")),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var sendMessage = _step5.value;\n              sendMessage.remove();\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          var _iterator6 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.receiveMessage\")),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var receiveMessage = _step6.value;\n              receiveMessage.remove();\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          var _iterator7 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.actionMessage\")),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var actionMessage = _step7.value;\n              actionMessage.remove();\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          that.connections.forEach(function (conn) {\n            var sourcePosition = that.getNodeConnectorOffset(conn.source.id, conn.source.position);\n            var destinationPosition = that.getNodeConnectorOffset(conn.destination.id, conn.destination.position);\n            var colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n              message: \"black\"\n            };\n\n            if (that.currentConnections.filter(function (item) {\n              return item === conn;\n            }).length > 0) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n                message: \"#52c41a\"\n              };\n            }\n\n            var result = that.arrowTo(sourcePosition.x, sourcePosition.y, destinationPosition.x, destinationPosition.y, conn.source.position, conn.destination.position, colors[\"message\"]);\n\n            var _iterator8 = _createForOfIteratorHelper(result.paths),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var path = _step8.value;\n                path.on(\"mousedown\", function (event) {\n                  d3.event.stopPropagation();\n\n                  if (that.pathClickedOnce) {\n                    that.editConnection(conn);\n                  } else {\n                    var timer = setTimeout(function () {\n                      that.pathClickedOnce = false;\n                      clearTimeout(timer);\n                    }, 300);\n                    that.pathClickedOnce = true;\n                  }\n\n                  that.currentNodes.splice(0, that.currentNodes.length);\n                  that.currentConnections.splice(0, that.currentConnections.length);\n                  that.currentConnections.push(conn);\n                });\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n\n            var _iterator9 = _createForOfIteratorHelper(result.lines),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var line = _step9.value;\n                that.lines.push({\n                  sourceX: line.sourceX,\n                  sourceY: line.sourceY,\n                  destinationX: line.destinationX,\n                  destinationY: line.destinationY,\n                  id: conn.id\n                });\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            var g = null;\n            var messages = [];\n\n            if (conn.source.type === \"receive\") {\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"receiveMessage\", true);\n\n              if (that.$store.getters.getNode(conn.receiveFrom)) {\n                messages.push(\"From: \" + that.$store.getters.getNode(conn.receiveFrom).text);\n\n                if (that.$store.getters.getOutgoingMessages(conn.receiveFrom, that.$store.getters.getSBD(conn.id).id).includes(conn.receiveMsg)) {\n                  messages.push(\"Msg: \" + conn.receiveMsg);\n                } else {\n                  messages.push(\"Msg: \");\n                  that.$store.commit('reset_msg', {\n                    nodeID: that.$store.getters.getSBD(conn.id).id,\n                    connectionSBDID: conn.id\n                  });\n                }\n              } else {\n                messages = [\"From: \", \"Msg: \"];\n                that.$store.commit('reset_msg', {\n                  nodeID: that.$store.getters.getSBD(conn.id).id,\n                  connectionSBDID: conn.id\n                });\n                that.$store.commit('set_from_to', {\n                  nodeID: that.$store.getters.getSBD(conn.id).id,\n                  connectionSBDID: conn.id,\n                  receive: \"\"\n                });\n              }\n            } else if (conn.source.type === \"send\") {\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"sendMessage\", true);\n\n              if (that.$store.getters.getNode(conn.sendTo)) {\n                messages.push(\"To: \" + that.$store.getters.getNode(conn.sendTo).text);\n\n                if (that.$store.getters.getIncomingMessages(conn.sendTo, that.$store.getters.getSBD(conn.id).id).includes(conn.sendMsg)) {\n                  messages.push(\"Msg: \" + conn.sendMsg);\n                } else {\n                  messages.push(\"Msg: \");\n                  that.$store.commit('reset_msg', {\n                    nodeID: that.$store.getters.getSBD(conn.id).id,\n                    connectionSBDID: conn.id\n                  });\n                }\n              } else {\n                messages = [\"From: \", \"Msg: \"];\n                that.$store.commit('reset_msg', {\n                  nodeID: that.$store.getters.getSBD(conn.id).id,\n                  connectionSBDID: conn.id\n                });\n                that.$store.commit('set_from_to', {\n                  nodeID: that.$store.getters.getSBD(conn.id).id,\n                  connectionSBDID: conn.id,\n                  send: \"\"\n                });\n              }\n            } else {\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"actionMessage\", true);\n              messages = conn.messages;\n            }\n\n            if (result.lines.length === 3) {\n              var xHelper = result.lines[1].sourceX + (result.lines[2].sourceX - result.lines[1].sourceX) / 2;\n              var yHelper = result.lines[1].sourceY + (result.lines[2].sourceY - result.lines[1].sourceY) / 2;\n              renderMessage(g, {\n                x: xHelper,\n                y: yHelper,\n                type: conn.source.type,\n                messages: messages\n              }, false);\n            } else {\n              renderMessage(g, {\n                x: result.lines[2].sourceX,\n                y: result.lines[2].sourceY,\n                type: conn.source.type,\n                messages: messages\n              }, false);\n            } //console.log(result.lines)\n\n\n            g.on(\"mousedown\", function (event) {\n              d3.event.stopPropagation();\n\n              if (that.pathClickedOnce) {\n                that.editConnection(conn);\n              } else {\n                var timer = setTimeout(function () {\n                  that.pathClickedOnce = false;\n                  clearTimeout(timer);\n                }, 300);\n                that.pathClickedOnce = true;\n              }\n\n              that.currentNodes.splice(0, that.currentNodes.length);\n              that.currentConnections.splice(0, that.currentConnections.length);\n              that.currentConnections.push(conn);\n            });\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes: function renderNodes() {\n      var that = this;\n      return new Promise(function (resolve) {\n        var _iterator10 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.node\")),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var node = _step10.value;\n            node.remove();\n          } // render nodes\n\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        that.nodes.forEach(function (node) {\n          that.renderNode(node, that.currentNodes.filter(function (item) {\n            return item === node;\n          }).length > 0);\n        });\n        resolve();\n      });\n    },\n    getNodeConnectorOffset: function getNodeConnectorOffset(nodeId, connectorPosition) {\n      var node = this.nodes.filter(function (item) {\n        return item.id === nodeId;\n      })[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append: function append(element) {\n      var svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo: function guideLineTo(x1, y1, x2, y2) {\n      var g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo: function arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      var g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      connect(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || \"#a3a3a3\", true); // a 5px cover to make mouse operation conveniently\n\n      return connect(g, x1, y1, x2, y2, startPosition, endPosition, 5, \"transparent\", false);\n    },\n    renderNode: function renderNode(node, isSelected) {\n      var that = this;\n      var g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      render(g, node, isSelected);\n      var drag = d3.drag().on(\"start\", function () {\n        // handle mousedown\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentConnections.splice(0, that.currentConnections.length);\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentNodes.push(node);\n        }\n\n        if (that.clickedOnce) {\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.editNode(node);\n        } else {\n          var timer = setTimeout(function () {\n            that.clickedOnce = false;\n            clearTimeout(timer);\n          }, 300);\n          that.clickedOnce = true;\n        }\n      }).on(\"drag\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var zoom, _iterator11, _step11, currentNode, x, y, _iterator12, _step12, element, edge, expectX, expectY;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!that.readonly) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n                _iterator11 = _createForOfIteratorHelper(that.currentNodes);\n\n                try {\n                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                    currentNode = _step11.value;\n                    x = d3.event.dx / zoom;\n\n                    if (currentNode.x + x < 0) {\n                      x = -currentNode.x;\n                    }\n\n                    currentNode.x += x;\n                    y = d3.event.dy / zoom;\n\n                    if (currentNode.y + y < 0) {\n                      y = -currentNode.y;\n                    }\n\n                    currentNode.y += y;\n                  }\n                } catch (err) {\n                  _iterator11.e(err);\n                } finally {\n                  _iterator11.f();\n                }\n\n                _iterator12 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.guideline\"));\n\n                try {\n                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                    element = _step12.value;\n                    element.remove();\n                  }\n                } catch (err) {\n                  _iterator12.e(err);\n                } finally {\n                  _iterator12.f();\n                }\n\n                edge = that.getCurrentNodesEdge();\n                expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n                expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n                that.nodes.forEach(function (item) {\n                  if (that.currentNodes.filter(function (currentNode) {\n                    return currentNode === item;\n                  }).length === 0) {\n                    if (item.x === expectX) {\n                      // vertical guideline\n                      if (item.y < expectY) {\n                        that.guideLineTo(item.x, item.y + item.height, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX, expectY + item.height, item.x, item.y);\n                      }\n                    }\n\n                    if (item.y === expectY) {\n                      // horizontal guideline\n                      if (item.x < expectX) {\n                        that.guideLineTo(item.x + item.width, item.y, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX + item.width, expectY, item.x, item.y);\n                      }\n                    }\n                  }\n                });\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))).on(\"end\", function () {\n        var _iterator13 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.guideline\")),\n            _step13;\n\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var element = _step13.value;\n            element.remove();\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n\n        var _iterator14 = _createForOfIteratorHelper(that.currentNodes),\n            _step14;\n\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var currentNode = _step14.value;\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n      var connectors = [];\n      var connectorPosition = this.getConnectorPosition(node);\n\n      var _loop = function _loop(position) {\n        var positionElement = connectorPosition[position];\n        var connector = g.append(\"circle\").attr(\"cx\", positionElement.x).attr(\"cy\", positionElement.y).attr(\"r\", 4).attr(\"class\", \"connector\");\n        connector.on(\"mousedown\", function () {\n          d3.event.stopPropagation();\n          that.connectingInfo.source = node;\n          that.connectingInfo.sourcePosition = position;\n        }).on(\"mouseup\", function () {\n          d3.event.stopPropagation();\n\n          if (that.connectingInfo.source) {\n            if (that.connectingInfo.source.id !== node.id) {\n              // Node can't connect to itself\n              var tempId = uuidv4();\n              var conn = {\n                source: {\n                  id: that.connectingInfo.source.id,\n                  position: that.connectingInfo.sourcePosition,\n                  type: that.connectingInfo.source.type\n                },\n                destination: {\n                  id: node.id,\n                  position: position\n                },\n                id: tempId,\n                messages: []\n              };\n\n              if (that.connectingInfo.source.type === \"send\") {\n                conn[\"sendTo\"] = \"\";\n                conn[\"sendMsg\"] = \"\";\n                conn[\"messages\"] = [\"To:\", \"Msg:\"];\n              } else if (that.connectingInfo.source.type === \"receive\") {\n                conn[\"receiveFrom\"] = \"\";\n                conn[\"receiveMsg\"] = \"\";\n                conn[\"messages\"] = [\"From:\", \"Msg:\"];\n              }\n\n              that.connections.push(conn);\n              that.$emit(\"connect\", conn, that.nodes, that.connections);\n            }\n\n            that.connectingInfo.source = null;\n            that.connectingInfo.sourcePosition = null;\n          }\n        }).on(\"mouseover\", function () {\n          connector.classed(\"active\", true);\n        }).on(\"mouseout\", function () {\n          connector.classed(\"active\", false);\n        });\n        connectors.push(connector);\n      };\n\n      for (var position in connectorPosition) {\n        _loop(position);\n      }\n\n      g.on(\"mouseover\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", true);\n        });\n      }).on(\"mouseout\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", false);\n        });\n      });\n    },\n    getCurrentNodesEdge: function getCurrentNodesEdge() {\n      var points = this.currentNodes.map(function (node) {\n        return {\n          x: node.x,\n          y: node.y\n        };\n      });\n      points.push.apply(points, _toConsumableArray(this.currentNodes.map(function (node) {\n        return {\n          x: node.x + node.width,\n          y: node.y + node.height\n        };\n      })));\n      return getEdgeOfPoints(points);\n    },\n    save: function save() {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"save\", this.nodes, this.connections);\n    },\n    remove: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        var _iterator15, _step15, conn, _iterator16, _step16, node;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.readonly) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                if (this.currentConnections.length > 0) {\n                  _iterator15 = _createForOfIteratorHelper(this.currentConnections);\n\n                  try {\n                    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                      conn = _step15.value;\n                      this.removeConnection(conn);\n                    }\n                  } catch (err) {\n                    _iterator15.e(err);\n                  } finally {\n                    _iterator15.f();\n                  }\n\n                  this.currentConnections.splice(0, this.currentConnections.length);\n                }\n\n                if (this.currentNodes.length > 0) {\n                  _iterator16 = _createForOfIteratorHelper(this.currentNodes);\n\n                  try {\n                    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                      node = _step16.value;\n                      this.removeNode(node);\n                    }\n                  } catch (err) {\n                    _iterator16.e(err);\n                  } finally {\n                    _iterator16.f();\n                  }\n\n                  this.currentNodes.splice(0, this.currentNodes.length);\n                }\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }(),\n    removeNode: function removeNode(node) {\n      var connections = this.connections.filter(function (item) {\n        return item.source.id === node.id || item.destination.id === node.id;\n      });\n\n      var _iterator17 = _createForOfIteratorHelper(connections),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var connection = _step17.value;\n          this.connections.splice(this.connections.indexOf(connection), 1);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.$emit(\"delete\", node, this.nodes, this.connections);\n    },\n    removeConnection: function removeConnection(conn) {\n      var index = this.connections.indexOf(conn);\n      this.connections.splice(index, 1);\n      this.$emit(\"disconnect\", conn, this.nodes, this.connections);\n    },\n    moveCurrentNode: function moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        var _iterator18 = _createForOfIteratorHelper(this.currentNodes),\n            _step18;\n\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var node = _step18.value;\n\n            if (node.x + x < 0) {\n              x = -node.x;\n            }\n\n            node.x += x;\n\n            if (node.y + y < 0) {\n              y = -node.y;\n            }\n\n            node.y += y;\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n      }\n    }\n  },\n  mounted: function mounted() {\n    this.renderNodes();\n    this.renderConnections();\n    var that = this;\n\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            var _that$currentNodes, _that$currentConnecti;\n\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n\n            (_that$currentNodes = that.currentNodes).push.apply(_that$currentNodes, _toConsumableArray(that.nodes));\n\n            (_that$currentConnecti = that.currentConnections).push.apply(_that$currentConnecti, _toConsumableArray(that.connections));\n\n            event.preventDefault();\n          }\n\n          break;\n\n        case 46:\n          that.remove();\n          break;\n\n        default:\n          break;\n      }\n    };\n  },\n  created: function created() {},\n  computed: {\n    connections: {\n      get: function get() {\n        var _this = this;\n\n        return this.$store.state.nodes.find(function (element) {\n          return element.id === _this.idSBD;\n        }).SBD.connections;\n      },\n      set: function set(newValue) {\n        return this.$store.dispatch('set_connections', {\n          id: this.idSBD,\n          connections: newValue\n        });\n      }\n    },\n    nodes: {\n      get: function get() {\n        var _this2 = this;\n\n        return this.$store.state.nodes.find(function (element) {\n          return element.id === _this2.idSBD;\n        }).SBD.nodes;\n      },\n      set: function set(newValue) {\n        return this.$store.commit('set_nodes', {\n          id: this.idSBD,\n          nodes: newValue\n        });\n      }\n    },\n    hoveredConnector: function hoveredConnector() {\n      var _iterator19 = _createForOfIteratorHelper(this.nodes),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var node = _step19.value;\n          var connectorPosition = this.getConnectorPosition(node);\n\n          for (var prop in connectorPosition) {\n            var entry = connectorPosition[prop];\n\n            if (Math.hypot(entry.x - this.cursorToChartOffset.x, entry.y - this.cursorToChartOffset.y) < 10) {\n              return {\n                position: prop,\n                node: node\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return null;\n    },\n    hoveredConnection: function hoveredConnection() {\n      var _this3 = this;\n\n      var _iterator20 = _createForOfIteratorHelper(this.lines),\n          _step20;\n\n      try {\n        var _loop2 = function _loop2() {\n          var line = _step20.value;\n          var distance = distanceOfPointToLine(line.sourceX, line.sourceY, line.destinationX, line.destinationY, _this3.cursorToChartOffset.x, _this3.cursorToChartOffset.y);\n\n          if (distance < 5 && between(line.sourceX - 2, line.destinationX + 2, _this3.cursorToChartOffset.x) && between(line.sourceY - 2, line.destinationY + 2, _this3.cursorToChartOffset.y)) {\n            var connections = _this3.connections.filter(function (item) {\n              return item.id === line.id;\n            });\n\n            return {\n              v: connections.length > 0 ? connections[0] : null\n            };\n          }\n        };\n\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _ret = _loop2();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      return null;\n    },\n    cursor: function cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n\n      return null;\n    }\n  },\n  watch: {\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderNodes();\n        this.renderConnections();\n      }\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderSelection();\n      }\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.$emit(\"select\", this.currentNodes);\n        this.renderNodes();\n      }\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.$emit(\"selectconnection\", this.currentConnections);\n        this.renderConnections();\n      }\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      }\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    }\n  }\n};",{"version":3,"mappings":"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","names":["between","distanceOfPointToLine","getEdgeOfPoints","pointRectangleIntersection","name","props","idSBD","type","width","default","height","readonly","data","connectingInfo","source","sourcePosition","selectionInfo","currentNodes","currentConnections","cursorToChartOffset","x","y","clickedOnce","pathClickedOnce","lines","methods","add","node","editCurrent","editNode","editConnection","connection","handleChartMouseWheel","event","zoom","svg","handleChartMouseUp","tempId","uuidv4","conn","id","position","destination","messages","handleChartMouseMove","boundingClientRect","actualX","actualY","document","element","sourceOffset","destinationPosition","result","handleChartDblClick","handleChartMouseDown","getConnectorPosition","left","right","top","bottom","renderSelection","that","rect","points","renderConnections","sendMessage","receiveMessage","actionMessage","pass","reject","message","colors","path","d3","clearTimeout","sourceX","sourceY","destinationX","destinationY","g","nodeID","connectionSBDID","receive","send","renderMessage","resolve","renderNodes","getNodeConnectorOffset","nodeId","connectorPosition","append","guideLineTo","x1","y1","x2","y2","lineTo","arrowTo","startPosition","endPosition","color","connect","renderNode","isSelected","render","drag","on","parseFloat","currentNode","edge","expectX","Math","expectY","length","item","attr","positionElement","connector","connectors","getCurrentNodesEdge","save","remove","removeNode","connections","removeConnection","moveCurrentNode","mounted","created","computed","get","set","newValue","nodes","hoveredConnector","entry","hoveredConnection","line","distance","cursor","watch","immediate","deep","handler"],"sourceRoot":"src/components/SBDflowchart","sources":["Flowchart.vue"],"sourcesContent":["<template>\n\n  <div\n    id=\"chart\"\n    tabindex=\"0\"\n    :style=\"{\n    cursor: cursor,\n    }\"\n    @mousemove=\"handleChartMouseMove\"\n    @mouseup=\"handleChartMouseUp\"\n    @dblclick=\"handleChartDblClick($event)\"\n    @mousewheel=\"handleChartMouseWheel\"\n    @mousedown=\"handleChartMouseDown($event)\"\n  >\n    <span id=\"position\" class=\"unselectable\">\n      {{ cursorToChartOffset.x + \", \" + cursorToChartOffset.y }}\n    </span>\n    <svg id=\"svg\">\n      <rect class=\"selection\" height=\"0\" width=\"0\"></rect>\n    </svg>\n  </div>\n</template>\n<style src=\"./index.css\"></style>\n<script>\nimport { connect, lineTo } from \"@/utils/svg\";\nimport * as d3 from \"d3\";\nimport {\n  between,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"@/utils/math\";\nimport render from \"./render\";\nimport renderMessage from \"./renderMessage\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { mapState } from 'vuex';\n\n\nexport default {\n  name: \"flowchart\",\n  props: {\n    idSBD: {\n    type: String\n    },\n    width: {\n      type: [String, Number],\n      default: 1000,\n    },\n    height: {\n      type: [String, Number],\n      default: 1000,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  data() {\n    return {\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all connections\n       */\n      lines: [],\n    };\n  },\n\n  methods: {\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.nodes.push(node);\n      this.$emit(\"add\", node, this.nodes, this.connections);\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editnode\", node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            \n            let tempId = uuidv4()\n              let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n                type: this.connectingInfo.source.type\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              messages: [],\n            };\n            if(this.connectingInfo.source.type===\"send\"){\n            conn[\"sendTo\"] = \"\"\n            conn[\"sendMsg\"] = \"\"\n            conn[\"messages\"] = [\"To:\", \"Msg:\"]\n            } else if(this.connectingInfo.source.type===\"receive\"){\n            conn[\"receiveFrom\"] = \"\"\n            conn[\"receiveMsg\"] = \"\"\n            conn[\"messages\"] = [\"From:\", \"Msg:\"]\n            } else if(this.connectingInfo.source.type===\"action\"){\n              conn[\"actionMsg\"] = \"\"\n            }\n            this.connections.push(conn);\n            this.$emit(\n              \"connect\",\n              conn,\n              this.nodes,\n              this.connections\n            );\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        for (let element of document.querySelectorAll(\"#svg .connector\")) {\n          element.classList.add(\"active\");\n        }\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        let result = this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          destinationPosition\n        );\n      }\n    },\n    handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"dblclick\", { x: event.offsetX, y: event.offsetY });\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    getConnectorPosition(node) {\n      const halfWidth = node.width / 2;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n\n        for (let rect of document.querySelectorAll(\"#svg .selection\")) {\n          rect.classList.add(\"active\");\n          rect.setAttribute(\"x\", edge.start.x);\n          rect.setAttribute(\"y\", edge.start.y);\n          rect.setAttribute(\"width\", edge.end.x - edge.start.x);\n          rect.setAttribute(\"height\", edge.end.y - edge.start.y);\n        }\n\n        that.nodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (points.some((point) => pointRectangleIntersection(point, edge))) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.connections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        for (let element of document.querySelectorAll(\"#svg > .selection\")) {\n          element.classList.remove(\"active\");\n        }\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          for (let element of document.querySelectorAll(\n            \"#svg > g.connection\"\n          )) {\n            element.remove();\n          }\n          // render lines\n          that.lines = [];\n          for (let sendMessage of document.querySelectorAll(\"#svg > g.sendMessage\")) {\n          sendMessage.remove();}\n          for (let receiveMessage of document.querySelectorAll(\"#svg > g.receiveMessage\")) {\n          receiveMessage.remove();}\n          for (let actionMessage of document.querySelectorAll(\"#svg > g.actionMessage\")) {\n          actionMessage.remove();}\n          that.connections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position\n            );\n            let colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n              message: \"black\"\n            };\n            if (\n              that.currentConnections.filter((item) => item === conn).length > 0\n            ) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n                message: \"#52c41a\"\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              colors[\"message\"]\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n            let g = null\n            let messages = []\n            if(conn.source.type===\"receive\"){\n               g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"receiveMessage\", true);\n               if(that.$store.getters.getNode(conn.receiveFrom)){\n                  messages.push(\"From: \" + that.$store.getters.getNode(conn.receiveFrom).text)\n                  if(that.$store.getters.getOutgoingMessages(conn.receiveFrom, that.$store.getters.getSBD(conn.id).id).includes(conn.receiveMsg)){\n                  messages.push(\"Msg: \" + conn.receiveMsg)\n                  } else {\n                    messages.push(\"Msg: \")\n                  that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                  }\n               } else {\n                 messages = [\"From: \", \"Msg: \"]\n                that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                that.$store.commit('set_from_to', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id, receive : \"\"})\n               }\n            } else if(conn.source.type===\"send\"){\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"sendMessage\", true);\n               if(that.$store.getters.getNode(conn.sendTo)){\n                  messages.push(\"To: \" + that.$store.getters.getNode(conn.sendTo).text)\n                  if(that.$store.getters.getIncomingMessages(conn.sendTo, that.$store.getters.getSBD(conn.id).id).includes(conn.sendMsg)){\n                       messages.push(\"Msg: \" + conn.sendMsg)\n                  } else {\n                    messages.push(\"Msg: \")\n                    that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                  }\n               } else {\n                 messages = [\"From: \", \"Msg: \"]\n                that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                that.$store.commit('set_from_to', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id, send : \"\"})\n\n              }\n            } else{\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"actionMessage\", true);\n              messages = conn.messages\n              }\n\n            if(result.lines.length === 3){\n            let xHelper = result.lines[1].sourceX + (result.lines[2].sourceX - result.lines[1].sourceX)/2\n            let yHelper = result.lines[1].sourceY + (result.lines[2].sourceY - result.lines[1].sourceY)/2            \n            renderMessage(g, {x: xHelper, y: yHelper, type: conn.source.type, messages: messages}, false);\n            } else {  \n            renderMessage(g, {x: result.lines[2].sourceX, y: result.lines[2].sourceY, type: conn.source.type, messages: messages}, false);\n            }\n            //console.log(result.lines)\n            g.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        for (let node of document.querySelectorAll(\"#svg > g.node\")) {\n          node.remove();\n        }\n        // render nodes\n        that.nodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.nodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      let g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        1,\n        color || \"#a3a3a3\",\n        true\n      );\n      // a 5px cover to make mouse operation conveniently\n      return connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      render(g, node, isSelected);\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            let x = d3.event.dx / zoom;\n            if (currentNode.x + x < 0) {\n              x = -currentNode.x;\n            }\n            currentNode.x += x;\n            let y = d3.event.dy / zoom;\n            if (currentNode.y + y < 0) {\n              y = -currentNode.y;\n            }\n            currentNode.y += y;\n          }\n\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.nodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = uuidv4();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                    type: that.connectingInfo.source.type,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  messages: []\n                };\n                if(that.connectingInfo.source.type===\"send\"){\n                conn[\"sendTo\"] = \"\"\n                conn[\"sendMsg\"] = \"\"\n                conn[\"messages\"] = [\"To:\", \"Msg:\"]\n                } else if(that.connectingInfo.source.type===\"receive\"){\n                conn[\"receiveFrom\"] = \"\"\n                conn[\"receiveMsg\"] = \"\"\n                conn[\"messages\"] = [\"From:\", \"Msg:\"]\n                }\n                that.connections.push(conn);\n                that.$emit(\n                  \"connect\",\n                  conn,\n                  that.nodes,\n                  that.connections\n                );\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"save\", this.nodes, this.connections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.connections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.connections.splice(\n          this.connections.indexOf(connection),\n          1\n        );\n      }\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.$emit(\"delete\", node, this.nodes, this.connections);\n    },\n    removeConnection(conn) {\n      let index = this.connections.indexOf(conn);\n      this.connections.splice(index, 1);\n      this.$emit(\n        \"disconnect\",\n        conn,\n        this.nodes,\n        this.connections\n      );\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          if (node.x + x < 0) {\n            x = -node.x;\n          }\n          node.x += x;\n          if (node.y + y < 0) {\n            y = -node.y;\n          }\n          node.y += y;\n        }\n      }\n    },\n\n  },\n  mounted() {\n    this.renderNodes()\n    this.renderConnections()\n    let that = this;\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.nodes);\n            that.currentConnections.push(...that.connections);\n            event.preventDefault();\n          }\n          break;\n        case 46:\n          that.remove();\n          break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n    connections: {\n    get () {\n      return this.$store.state.nodes.find(element => element.id === this.idSBD).SBD.connections\n    },\n    set (newValue) {\n      return this.$store.dispatch('set_connections', {id : this.idSBD, connections : newValue})\n    }\n  },\n    nodes: {\n    get () {\n      return this.$store.state.nodes.find(element => element.id === this.idSBD).SBD.nodes\n    },\n    set (newValue) {\n      return this.$store.commit('set_nodes', {id : this.idSBD, nodes : newValue})\n    }\n  },\n    hoveredConnector() {\n      for (const node of this.nodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.connections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"select\", this.currentNodes);\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"selectconnection\", this.currentConnections);\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n\n  },\n};\n</script>\n"]}]}