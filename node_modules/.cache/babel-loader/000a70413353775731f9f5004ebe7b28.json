{"remainingRequest":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/thread-loader/dist/cjs.js!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/babel-loader/lib/index.js!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/src/components/SIDflowchart/Flowchart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/src/components/SIDflowchart/Flowchart.vue","mtime":1655374783490},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/babel.config.js","mtime":1654095143863},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js","mtime":1655376985815},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/thread-loader/dist/cjs.js","mtime":1655376985502},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/babel-loader/lib/index.js","mtime":1655376985883},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js","mtime":1655376985815},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/vue-loader/lib/index.js","mtime":1655376986005}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport _typeof from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/typeof.js\";\nimport \"core-js/modules/es6.math.hypot\";\nimport _defineProperty from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.math.trunc\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es6.number.constructor\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { connect, lineTo } from \"@/utils/svg\";\nimport * as d3 from \"d3\";\nimport { between, distanceOfPointToLine, getEdgeOfPoints, pointRectangleIntersection } from \"@/utils/math\";\nimport render from \"./render\";\nimport renderMessage from \"./renderMessage\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { mapState } from 'vuex';\nexport default {\n  name: \"flowchart\",\n  props: {\n    width: {\n      type: [String, Number],\n      default: 1000\n    },\n    height: {\n      type: [String, Number],\n      default: 1000\n    },\n    readonly: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function data() {\n    return {\n      connectingInfo: {\n        source: null,\n        sourcePosition: null\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: {\n        x: 0,\n        y: 0\n      },\n      clickedOnce: false,\n      pathClickedOnce: false,\n\n      /**\n       * lines of all connections\n       */\n      lines: []\n    };\n  },\n  methods: {\n    add: function add(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.nodes.push(node);\n      this.$emit(\"add\", node, this.nodes, this.connections);\n    },\n    editCurrent: function editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode: function editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editnode\", node);\n    },\n    editConnection: function editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel: function handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (event.ctrlKey) {\n        var svg = document.getElementById(\"svg\");\n        var zoom = parseFloat(svg.style.zoom || 1);\n\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    handleChartMouseUp: function () {\n      var _handleChartMouseUp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var tempId, conn;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.connectingInfo.source) {\n                  if (this.hoveredConnector) {\n                    if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n                      // Node can't connect to itself\n                      tempId = uuidv4();\n                      conn = {\n                        source: {\n                          id: this.connectingInfo.source.id,\n                          position: this.connectingInfo.sourcePosition\n                        },\n                        destination: {\n                          id: this.hoveredConnector.node.id,\n                          position: this.hoveredConnector.position\n                        },\n                        id: tempId,\n                        messages: []\n                      };\n                      this.connections.push(conn);\n                      this.$emit(\"connect\", conn, this.nodes, this.connections);\n                    }\n                  }\n\n                  this.connectingInfo.source = null;\n                  this.connectingInfo.sourcePosition = null;\n                }\n\n                if (this.selectionInfo) {\n                  this.selectionInfo = null;\n                }\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleChartMouseUp() {\n        return _handleChartMouseUp.apply(this, arguments);\n      }\n\n      return handleChartMouseUp;\n    }(),\n    handleChartMouseMove: function () {\n      var _handleChartMouseMove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(event) {\n        var boundingClientRect, actualX, actualY, _iterator, _step, element, sourceOffset, destinationPosition, result;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // calc offset of cursor to chart\n                boundingClientRect = event.currentTarget.getBoundingClientRect();\n                actualX = event.pageX - boundingClientRect.left - window.scrollX;\n                this.cursorToChartOffset.x = Math.trunc(actualX);\n                actualY = event.pageY - boundingClientRect.top - window.scrollY;\n                this.cursorToChartOffset.y = Math.trunc(actualY);\n\n                if (!this.connectingInfo.source) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                _context2.next = 8;\n                return this.renderConnections();\n\n              case 8:\n                _iterator = _createForOfIteratorHelper(document.querySelectorAll(\"#svg .connector\"));\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    element = _step.value;\n                    element.classList.add(\"active\");\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                sourceOffset = this.getNodeConnectorOffset(this.connectingInfo.source.id, this.connectingInfo.sourcePosition);\n                destinationPosition = this.hoveredConnector ? this.hoveredConnector.position : null;\n                result = this.arrowTo(sourceOffset.x, sourceOffset.y, this.cursorToChartOffset.x, this.cursorToChartOffset.y, this.connectingInfo.sourcePosition, destinationPosition);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function handleChartMouseMove(_x) {\n        return _handleChartMouseMove.apply(this, arguments);\n      }\n\n      return handleChartMouseMove;\n    }(),\n    handleChartDblClick: function handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"dblclick\", {\n        x: event.offsetX,\n        y: event.offsetY\n      });\n    },\n    handleChartMouseDown: function handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n\n      this.selectionInfo = {\n        x: event.offsetX,\n        y: event.offsetY\n      };\n    },\n    getConnectorPosition: function getConnectorPosition(node) {\n      var halfWidth = node.width / 2;\n      var halfHeight = node.height / 2;\n      var top = {\n        x: node.x + halfWidth,\n        y: node.y\n      };\n      var left = {\n        x: node.x,\n        y: node.y + halfHeight\n      };\n      var bottom = {\n        x: node.x + halfWidth,\n        y: node.y + node.height\n      };\n      var right = {\n        x: node.x + node.width,\n        y: node.y + halfHeight\n      };\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    },\n    renderSelection: function renderSelection() {\n      var that = this; // render selection rectangle\n\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        var edge = getEdgeOfPoints([{\n          x: that.selectionInfo.x,\n          y: that.selectionInfo.y\n        }, {\n          x: that.cursorToChartOffset.x,\n          y: that.cursorToChartOffset.y\n        }]);\n\n        var _iterator2 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg .selection\")),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var rect = _step2.value;\n            rect.classList.add(\"active\");\n            rect.setAttribute(\"x\", edge.start.x);\n            rect.setAttribute(\"y\", edge.start.y);\n            rect.setAttribute(\"width\", edge.end.x - edge.start.x);\n            rect.setAttribute(\"height\", edge.end.y - edge.start.y);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        that.nodes.forEach(function (item) {\n          var points = [{\n            x: item.x,\n            y: item.y\n          }, {\n            x: item.x,\n            y: item.y + item.height\n          }, {\n            x: item.x + item.width,\n            y: item.y\n          }, {\n            x: item.x + item.width,\n            y: item.y + item.height\n          }];\n\n          if (points.some(function (point) {\n            return pointRectangleIntersection(point, edge);\n          })) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach(function (line) {\n          var points = [{\n            x: line.sourceX,\n            y: line.sourceY\n          }, {\n            x: line.destinationX,\n            y: line.destinationY\n          }];\n\n          if (points.every(function (point) {\n            return pointRectangleIntersection(point, edge);\n          }) && that.currentConnections.every(function (item) {\n            return item.id !== line.id;\n          })) {\n            var connection = that.connections.filter(function (conn) {\n              return conn.id === line.id;\n            })[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > .selection\")),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var element = _step3.value;\n            element.classList.remove(\"active\");\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    },\n    renderConnections: function renderConnections() {\n      var that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          var _iterator4 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.connection\")),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var element = _step4.value;\n              element.remove();\n            } // render lines\n\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          that.lines = [];\n\n          var _iterator5 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.nodeMessage\")),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var nodeMessage = _step5.value;\n              nodeMessage.remove();\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          that.connections.forEach(function (conn) {\n            var sourcePosition = that.getNodeConnectorOffset(conn.source.id, conn.source.position);\n            var destinationPosition = that.getNodeConnectorOffset(conn.destination.id, conn.destination.position);\n            var colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n              message: \"black\"\n            };\n\n            if (that.currentConnections.filter(function (item) {\n              return item === conn;\n            }).length > 0) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n                message: \"#52c41a\"\n              };\n            }\n\n            var result = that.arrowTo(sourcePosition.x, sourcePosition.y, destinationPosition.x, destinationPosition.y, conn.source.position, conn.destination.position, colors[\"message\"]);\n\n            var _iterator6 = _createForOfIteratorHelper(result.paths),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var path = _step6.value;\n                path.on(\"mousedown\", function (event) {\n                  d3.event.stopPropagation();\n\n                  if (that.pathClickedOnce) {\n                    that.editConnection(conn);\n                  } else {\n                    var timer = setTimeout(function () {\n                      that.pathClickedOnce = false;\n                      clearTimeout(timer);\n                    }, 300);\n                    that.pathClickedOnce = true;\n                  }\n\n                  that.currentNodes.splice(0, that.currentNodes.length);\n                  that.currentConnections.splice(0, that.currentConnections.length);\n                  that.currentConnections.push(conn);\n                });\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            var _iterator7 = _createForOfIteratorHelper(result.lines),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var line = _step7.value;\n                that.lines.push({\n                  sourceX: line.sourceX,\n                  sourceY: line.sourceY,\n                  destinationX: line.destinationX,\n                  destinationY: line.destinationY,\n                  id: conn.id\n                });\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n\n            var g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"nodeMessage\", true);\n\n            if (result.lines.length === 3) {\n              var xHelper = result.lines[1].sourceX + (result.lines[2].sourceX - result.lines[1].sourceX) / 2;\n              var yHelper = result.lines[1].sourceY + (result.lines[2].sourceY - result.lines[1].sourceY) / 2;\n              renderMessage(g, {\n                x: xHelper,\n                y: yHelper,\n                type: 'message',\n                messages: conn.messages\n              }, false);\n            } else {\n              renderMessage(g, {\n                x: result.lines[2].sourceX,\n                y: result.lines[2].sourceY,\n                type: 'message',\n                messages: conn.messages\n              }, false);\n            } //console.log(result.lines)\n\n\n            g.on(\"mousedown\", function (event) {\n              d3.event.stopPropagation();\n\n              if (that.pathClickedOnce) {\n                that.editConnection(conn);\n              } else {\n                var timer = setTimeout(function () {\n                  that.pathClickedOnce = false;\n                  clearTimeout(timer);\n                }, 300);\n                that.pathClickedOnce = true;\n              }\n\n              that.currentNodes.splice(0, that.currentNodes.length);\n              that.currentConnections.splice(0, that.currentConnections.length);\n              that.currentConnections.push(conn);\n            });\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes: function renderNodes() {\n      var that = this;\n      return new Promise(function (resolve) {\n        var _iterator8 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.node\")),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var node = _step8.value;\n            node.remove();\n          } // render nodes\n\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        that.nodes.forEach(function (node) {\n          that.renderNode(node, that.currentNodes.filter(function (item) {\n            return item === node;\n          }).length > 0);\n        });\n        resolve();\n      });\n    },\n    getNodeConnectorOffset: function getNodeConnectorOffset(nodeId, connectorPosition) {\n      var node = this.nodes.filter(function (item) {\n        return item.id === nodeId;\n      })[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append: function append(element) {\n      var svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo: function guideLineTo(x1, y1, x2, y2) {\n      var g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo: function arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      var g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      connect(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || \"#a3a3a3\", true); // a 5px cover to make mouse operation conveniently\n\n      return connect(g, x1, y1, x2, y2, startPosition, endPosition, 5, \"transparent\", false);\n    },\n    renderNode: function renderNode(node, isSelected) {\n      var that = this;\n      var g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      render(g, node, isSelected);\n      var drag = d3.drag().on(\"start\", function () {\n        // handle mousedown\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentConnections.splice(0, that.currentConnections.length);\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentNodes.push(node);\n        }\n\n        if (that.clickedOnce) {\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.editNode(node);\n        } else {\n          var timer = setTimeout(function () {\n            that.clickedOnce = false;\n            clearTimeout(timer);\n          }, 300);\n          that.clickedOnce = true;\n        }\n      }).on(\"drag\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var zoom, _iterator9, _step9, currentNode, x, y, _iterator10, _step10, element, edge, expectX, expectY;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!that.readonly) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n                _iterator9 = _createForOfIteratorHelper(that.currentNodes);\n\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    currentNode = _step9.value;\n                    x = d3.event.dx / zoom;\n\n                    if (currentNode.x + x < 0) {\n                      x = -currentNode.x;\n                    }\n\n                    currentNode.x += x;\n                    y = d3.event.dy / zoom;\n\n                    if (currentNode.y + y < 0) {\n                      y = -currentNode.y;\n                    }\n\n                    currentNode.y += y;\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n\n                _iterator10 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.guideline\"));\n\n                try {\n                  for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                    element = _step10.value;\n                    element.remove();\n                  }\n                } catch (err) {\n                  _iterator10.e(err);\n                } finally {\n                  _iterator10.f();\n                }\n\n                edge = that.getCurrentNodesEdge();\n                expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n                expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n                that.nodes.forEach(function (item) {\n                  if (that.currentNodes.filter(function (currentNode) {\n                    return currentNode === item;\n                  }).length === 0) {\n                    if (item.x === expectX) {\n                      // vertical guideline\n                      if (item.y < expectY) {\n                        that.guideLineTo(item.x, item.y + item.height, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX, expectY + item.height, item.x, item.y);\n                      }\n                    }\n\n                    if (item.y === expectY) {\n                      // horizontal guideline\n                      if (item.x < expectX) {\n                        that.guideLineTo(item.x + item.width, item.y, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX + item.width, expectY, item.x, item.y);\n                      }\n                    }\n                  }\n                });\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))).on(\"end\", function () {\n        var _iterator11 = _createForOfIteratorHelper(document.querySelectorAll(\"#svg > g.guideline\")),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var element = _step11.value;\n            element.remove();\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        var _iterator12 = _createForOfIteratorHelper(that.currentNodes),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var currentNode = _step12.value;\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n      var connectors = [];\n      var connectorPosition = this.getConnectorPosition(node);\n\n      var _loop = function _loop(position) {\n        var positionElement = connectorPosition[position];\n        var connector = g.append(\"circle\").attr(\"cx\", positionElement.x).attr(\"cy\", positionElement.y).attr(\"r\", 4).attr(\"class\", \"connector\");\n        connector.on(\"mousedown\", function () {\n          d3.event.stopPropagation();\n          that.connectingInfo.source = node;\n          that.connectingInfo.sourcePosition = position;\n        }).on(\"mouseup\", function () {\n          d3.event.stopPropagation();\n\n          if (that.connectingInfo.source) {\n            if (that.connectingInfo.source.id !== node.id) {\n              // Node can't connect to itself\n              var tempId = uuidv4();\n              var conn = {\n                source: {\n                  id: that.connectingInfo.source.id,\n                  position: that.connectingInfo.sourcePosition\n                },\n                destination: {\n                  id: node.id,\n                  position: position\n                },\n                id: tempId,\n                messages: []\n              };\n              that.connections.push(conn);\n              that.$emit(\"connect\", conn, that.nodes, that.connections);\n            }\n\n            that.connectingInfo.source = null;\n            that.connectingInfo.sourcePosition = null;\n          }\n        }).on(\"mouseover\", function () {\n          connector.classed(\"active\", true);\n        }).on(\"mouseout\", function () {\n          connector.classed(\"active\", false);\n        });\n        connectors.push(connector);\n      };\n\n      for (var position in connectorPosition) {\n        _loop(position);\n      }\n\n      g.on(\"mouseover\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", true);\n        });\n      }).on(\"mouseout\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", false);\n        });\n      });\n    },\n    getCurrentNodesEdge: function getCurrentNodesEdge() {\n      var points = this.currentNodes.map(function (node) {\n        return {\n          x: node.x,\n          y: node.y\n        };\n      });\n      points.push.apply(points, _toConsumableArray(this.currentNodes.map(function (node) {\n        return {\n          x: node.x + node.width,\n          y: node.y + node.height\n        };\n      })));\n      return getEdgeOfPoints(points);\n    },\n    save: function save() {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"save\", this.nodes, this.connections);\n    },\n    remove: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        var _iterator13, _step13, conn, _iterator14, _step14, node;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.readonly) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                if (this.currentConnections.length > 0) {\n                  _iterator13 = _createForOfIteratorHelper(this.currentConnections);\n\n                  try {\n                    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                      conn = _step13.value;\n                      this.removeConnection(conn);\n                    }\n                  } catch (err) {\n                    _iterator13.e(err);\n                  } finally {\n                    _iterator13.f();\n                  }\n\n                  this.currentConnections.splice(0, this.currentConnections.length);\n                }\n\n                if (this.currentNodes.length > 0) {\n                  _iterator14 = _createForOfIteratorHelper(this.currentNodes);\n\n                  try {\n                    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                      node = _step14.value;\n                      this.removeNode(node);\n                    }\n                  } catch (err) {\n                    _iterator14.e(err);\n                  } finally {\n                    _iterator14.f();\n                  }\n\n                  this.currentNodes.splice(0, this.currentNodes.length);\n                }\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }(),\n    removeNode: function removeNode(node) {\n      var connections = this.connections.filter(function (item) {\n        return item.source.id === node.id || item.destination.id === node.id;\n      });\n\n      var _iterator15 = _createForOfIteratorHelper(connections),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var connection = _step15.value;\n          this.connections.splice(this.connections.indexOf(connection), 1);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.$emit(\"delete\", node, this.nodes, this.connections);\n    },\n    removeConnection: function removeConnection(conn) {\n      var index = this.connections.indexOf(conn);\n      this.connections.splice(index, 1);\n      this.$emit(\"disconnect\", conn, this.nodes, this.connections);\n    },\n    moveCurrentNode: function moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        var _iterator16 = _createForOfIteratorHelper(this.currentNodes),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var node = _step16.value;\n\n            if (node.x + x < 0) {\n              x = -node.x;\n            }\n\n            node.x += x;\n\n            if (node.y + y < 0) {\n              y = -node.y;\n            }\n\n            node.y += y;\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n    }\n  },\n  mounted: function mounted() {\n    this.renderNodes();\n    this.renderConnections();\n    var that = this;\n\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            var _that$currentNodes, _that$currentConnecti;\n\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n\n            (_that$currentNodes = that.currentNodes).push.apply(_that$currentNodes, _toConsumableArray(that.nodes));\n\n            (_that$currentConnecti = that.currentConnections).push.apply(_that$currentConnecti, _toConsumableArray(that.connections));\n\n            event.preventDefault();\n          }\n\n          break;\n\n        case 46:\n          that.remove();\n          break;\n\n        default:\n          break;\n      }\n    };\n  },\n  created: function created() {},\n  computed: _objectSpread(_objectSpread({}, mapState(['connections', 'nodes'])), {}, {\n    hoveredConnector: function hoveredConnector() {\n      var _iterator17 = _createForOfIteratorHelper(this.nodes),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var node = _step17.value;\n          var connectorPosition = this.getConnectorPosition(node);\n\n          for (var prop in connectorPosition) {\n            var entry = connectorPosition[prop];\n\n            if (Math.hypot(entry.x - this.cursorToChartOffset.x, entry.y - this.cursorToChartOffset.y) < 10) {\n              return {\n                position: prop,\n                node: node\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      return null;\n    },\n    hoveredConnection: function hoveredConnection() {\n      var _this = this;\n\n      var _iterator18 = _createForOfIteratorHelper(this.lines),\n          _step18;\n\n      try {\n        var _loop2 = function _loop2() {\n          var line = _step18.value;\n          var distance = distanceOfPointToLine(line.sourceX, line.sourceY, line.destinationX, line.destinationY, _this.cursorToChartOffset.x, _this.cursorToChartOffset.y);\n\n          if (distance < 5 && between(line.sourceX - 2, line.destinationX + 2, _this.cursorToChartOffset.x) && between(line.sourceY - 2, line.destinationY + 2, _this.cursorToChartOffset.y)) {\n            var connections = _this.connections.filter(function (item) {\n              return item.id === line.id;\n            });\n\n            return {\n              v: connections.length > 0 ? connections[0] : null\n            };\n          }\n        };\n\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var _ret = _loop2();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      return null;\n    },\n    cursor: function cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n\n      return null;\n    }\n  }),\n  watch: {\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderNodes();\n        this.renderConnections();\n      }\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderSelection();\n      }\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.$emit(\"select\", this.currentNodes);\n        this.renderNodes();\n      }\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.$emit(\"selectconnection\", this.currentConnections);\n        this.renderConnections();\n      }\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      }\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    }\n  }\n};",{"version":3,"mappings":"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","names":["between","distanceOfPointToLine","getEdgeOfPoints","pointRectangleIntersection","name","props","width","type","default","height","readonly","data","connectingInfo","source","sourcePosition","selectionInfo","currentNodes","currentConnections","cursorToChartOffset","x","y","clickedOnce","pathClickedOnce","lines","methods","add","node","editCurrent","editNode","editConnection","connection","handleChartMouseWheel","event","zoom","svg","handleChartMouseUp","tempId","uuidv4","conn","id","position","destination","messages","handleChartMouseMove","boundingClientRect","actualX","actualY","document","element","sourceOffset","destinationPosition","result","handleChartDblClick","handleChartMouseDown","getConnectorPosition","left","right","top","bottom","renderSelection","that","rect","points","renderConnections","nodeMessage","pass","reject","message","colors","path","d3","clearTimeout","sourceX","sourceY","destinationX","destinationY","renderMessage","g","resolve","renderNodes","getNodeConnectorOffset","nodeId","connectorPosition","append","guideLineTo","x1","y1","x2","y2","lineTo","arrowTo","startPosition","endPosition","color","connect","renderNode","isSelected","render","drag","on","parseFloat","currentNode","edge","expectX","Math","expectY","length","item","attr","positionElement","connector","connectors","getCurrentNodesEdge","save","remove","removeNode","connections","removeConnection","moveCurrentNode","mounted","created","computed","mapState","hoveredConnector","entry","hoveredConnection","line","distance","cursor","watch","nodes","immediate","deep","handler"],"sourceRoot":"src/components/SIDflowchart","sources":["Flowchart.vue"],"sourcesContent":["<template>\n  <div\n    id=\"chart\"\n    tabindex=\"0\"\n    :style=\"{\n    cursor: cursor,\n    }\"\n    @mousemove=\"handleChartMouseMove\"\n    @mouseup=\"handleChartMouseUp\"\n    @dblclick=\"handleChartDblClick($event)\"\n    @mousewheel=\"handleChartMouseWheel\"\n    @mousedown=\"handleChartMouseDown($event)\"\n  >\n    <span id=\"position\" class=\"unselectable\">\n      {{ cursorToChartOffset.x + \", \" + cursorToChartOffset.y }}\n    </span>\n    <svg id=\"svg\">\n      <rect class=\"selection\" height=\"0\" width=\"0\"></rect>\n    </svg>\n  </div>\n</template>\n<style src=\"./index.css\"></style>\n<script>\nimport { connect, lineTo } from \"@/utils/svg\";\nimport * as d3 from \"d3\";\nimport {\n  between,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"@/utils/math\";\nimport render from \"./render\";\nimport renderMessage from \"./renderMessage\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { mapState } from 'vuex';\n\n\nexport default {\n  name: \"flowchart\",\n  props: {\n\n    width: {\n      type: [String, Number],\n      default: 1000,\n    },\n    height: {\n      type: [String, Number],\n      default: 1000,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  data() {\n    return {\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all connections\n       */\n      lines: [],\n    };\n  },\n\n  methods: {\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.nodes.push(node);\n      this.$emit(\"add\", node, this.nodes, this.connections);\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editnode\", node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            let tempId = uuidv4()\n            let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              messages: [],\n            };\n            this.connections.push(conn);\n            this.$emit(\n              \"connect\",\n              conn,\n              this.nodes,\n              this.connections\n            );\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n        for (let element of document.querySelectorAll(\"#svg .connector\")) {\n          element.classList.add(\"active\");\n        }\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        let result = this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          destinationPosition\n        );\n      }\n    },\n    handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"dblclick\", { x: event.offsetX, y: event.offsetY });\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    getConnectorPosition(node) {\n      const halfWidth = node.width / 2;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n\n        for (let rect of document.querySelectorAll(\"#svg .selection\")) {\n          rect.classList.add(\"active\");\n          rect.setAttribute(\"x\", edge.start.x);\n          rect.setAttribute(\"y\", edge.start.y);\n          rect.setAttribute(\"width\", edge.end.x - edge.start.x);\n          rect.setAttribute(\"height\", edge.end.y - edge.start.y);\n        }\n\n        that.nodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (points.some((point) => pointRectangleIntersection(point, edge))) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.connections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        for (let element of document.querySelectorAll(\"#svg > .selection\")) {\n          element.classList.remove(\"active\");\n        }\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          for (let element of document.querySelectorAll(\n            \"#svg > g.connection\"\n          )) {\n            element.remove();\n          }\n          // render lines\n          that.lines = [];\n          for (let nodeMessage of document.querySelectorAll(\"#svg > g.nodeMessage\")) {\n          nodeMessage.remove();\n        }\n          that.connections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position\n            );\n            let colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n              message: \"black\"\n            };\n            if (\n              that.currentConnections.filter((item) => item === conn).length > 0\n            ) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n                message: \"#52c41a\"\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              colors[\"message\"]\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n            let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"nodeMessage\", true);\n\n            if(result.lines.length === 3){\n            let xHelper = result.lines[1].sourceX + (result.lines[2].sourceX - result.lines[1].sourceX)/2\n            let yHelper = result.lines[1].sourceY + (result.lines[2].sourceY - result.lines[1].sourceY)/2\n            renderMessage(g, {x: xHelper, y: yHelper, type: 'message', messages: conn.messages}, false);\n            } else {  \n            renderMessage(g, {x: result.lines[2].sourceX, y: result.lines[2].sourceY, type: 'message', messages: conn.messages}, false);\n            }\n            //console.log(result.lines)\n            g.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        for (let node of document.querySelectorAll(\"#svg > g.node\")) {\n          node.remove();\n        }\n        // render nodes\n        that.nodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.nodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      let g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        1,\n        color || \"#a3a3a3\",\n        true\n      );\n      // a 5px cover to make mouse operation conveniently\n      return connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      render(g, node, isSelected);\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            let x = d3.event.dx / zoom;\n            if (currentNode.x + x < 0) {\n              x = -currentNode.x;\n            }\n            currentNode.x += x;\n            let y = d3.event.dy / zoom;\n            if (currentNode.y + y < 0) {\n              y = -currentNode.y;\n            }\n            currentNode.y += y;\n          }\n\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.nodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = uuidv4();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  messages: []\n                };\n                that.connections.push(conn);\n                that.$emit(\n                  \"connect\",\n                  conn,\n                  that.nodes,\n                  that.connections\n                );\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"save\", this.nodes, this.connections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.connections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.connections.splice(\n          this.connections.indexOf(connection),\n          1\n        );\n      }\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.$emit(\"delete\", node, this.nodes, this.connections);\n    },\n    removeConnection(conn) {\n      let index = this.connections.indexOf(conn);\n      this.connections.splice(index, 1);\n      this.$emit(\n        \"disconnect\",\n        conn,\n        this.nodes,\n        this.connections\n      );\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          if (node.x + x < 0) {\n            x = -node.x;\n          }\n          node.x += x;\n          if (node.y + y < 0) {\n            y = -node.y;\n          }\n          node.y += y;\n        }\n      }\n    },\n\n  },\n  mounted() {\n    this.renderNodes()\n    this.renderConnections()\n    let that = this;\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.nodes);\n            that.currentConnections.push(...that.connections);\n            event.preventDefault();\n          }\n          break;\n        case 46:\n          that.remove();\n          break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n      ...mapState(['connections', 'nodes']),\n    hoveredConnector() {\n      for (const node of this.nodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.connections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"select\", this.currentNodes);\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"selectconnection\", this.currentConnections);\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n\n  },\n};\n</script>\n"]}]}