{"remainingRequest":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/src/components/SBDflowchart/Flowchart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/src/components/SBDflowchart/Flowchart.vue","mtime":1655112394031},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js","mtime":1655376985815},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/babel-loader/lib/index.js","mtime":1655376985883},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/cache-loader/dist/cjs.js","mtime":1655376985815},{"path":"/Users/leonhanschmann/Python_projects/PASS-web-app/PASS/node_modules/vue-loader/lib/index.js","mtime":1655376986005}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { connect, lineTo } from \"@/utils/svg\";\nimport * as d3 from \"d3\";\nimport {\n  between,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"@/utils/math\";\nimport render from \"./render\";\nimport renderMessage from \"./renderMessage\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { mapState } from 'vuex';\n\n\nexport default {\n  name: \"flowchart\",\n  props: {\n    idSBD: {\n    type: String\n    },\n    width: {\n      type: [String, Number],\n      default: 1000,\n    },\n    height: {\n      type: [String, Number],\n      default: 1000,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  data() {\n    return {\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all connections\n       */\n      lines: [],\n    };\n  },\n\n  methods: {\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.nodes.push(node);\n      this.$emit(\"add\", node, this.nodes, this.connections);\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editnode\", node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            \n            let tempId = uuidv4()\n              let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n                type: this.connectingInfo.source.type\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              messages: [],\n            };\n            if(this.connectingInfo.source.type===\"send\"){\n            conn[\"sendTo\"] = \"\"\n            conn[\"sendMsg\"] = \"\"\n            conn[\"messages\"] = [\"To:\", \"Msg:\"]\n            } else if(this.connectingInfo.source.type===\"receive\"){\n            conn[\"receiveFrom\"] = \"\"\n            conn[\"receiveMsg\"] = \"\"\n            conn[\"messages\"] = [\"From:\", \"Msg:\"]\n            } else if(this.connectingInfo.source.type===\"action\"){\n              conn[\"actionMsg\"] = \"\"\n            }\n            this.connections.push(conn);\n            this.$emit(\n              \"connect\",\n              conn,\n              this.nodes,\n              this.connections\n            );\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        for (let element of document.querySelectorAll(\"#svg .connector\")) {\n          element.classList.add(\"active\");\n        }\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        let result = this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          destinationPosition\n        );\n      }\n    },\n    handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"dblclick\", { x: event.offsetX, y: event.offsetY });\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    getConnectorPosition(node) {\n      const halfWidth = node.width / 2;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n\n        for (let rect of document.querySelectorAll(\"#svg .selection\")) {\n          rect.classList.add(\"active\");\n          rect.setAttribute(\"x\", edge.start.x);\n          rect.setAttribute(\"y\", edge.start.y);\n          rect.setAttribute(\"width\", edge.end.x - edge.start.x);\n          rect.setAttribute(\"height\", edge.end.y - edge.start.y);\n        }\n\n        that.nodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (points.some((point) => pointRectangleIntersection(point, edge))) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.connections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        for (let element of document.querySelectorAll(\"#svg > .selection\")) {\n          element.classList.remove(\"active\");\n        }\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          for (let element of document.querySelectorAll(\n            \"#svg > g.connection\"\n          )) {\n            element.remove();\n          }\n          // render lines\n          that.lines = [];\n          for (let sendMessage of document.querySelectorAll(\"#svg > g.sendMessage\")) {\n          sendMessage.remove();}\n          for (let receiveMessage of document.querySelectorAll(\"#svg > g.receiveMessage\")) {\n          receiveMessage.remove();}\n          for (let actionMessage of document.querySelectorAll(\"#svg > g.actionMessage\")) {\n          actionMessage.remove();}\n          that.connections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position\n            );\n            let colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n              message: \"black\"\n            };\n            if (\n              that.currentConnections.filter((item) => item === conn).length > 0\n            ) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n                message: \"#52c41a\"\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              colors[\"message\"]\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n            let g = null\n            let messages = []\n            if(conn.source.type===\"receive\"){\n               g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"receiveMessage\", true);\n               if(that.$store.getters.getNode(conn.receiveFrom)){\n                  messages.push(\"From: \" + that.$store.getters.getNode(conn.receiveFrom).text)\n                  if(that.$store.getters.getOutgoingMessages(conn.receiveFrom, that.$store.getters.getSBD(conn.id).id).includes(conn.receiveMsg)){\n                  messages.push(\"Msg: \" + conn.receiveMsg)\n                  } else {\n                    messages.push(\"Msg: \")\n                  that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                  }\n               } else {\n                 messages = [\"From: \", \"Msg: \"]\n                that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                that.$store.commit('set_from_to', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id, receive : \"\"})\n               }\n            } else if(conn.source.type===\"send\"){\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"sendMessage\", true);\n               if(that.$store.getters.getNode(conn.sendTo)){\n                  messages.push(\"To: \" + that.$store.getters.getNode(conn.sendTo).text)\n                  if(that.$store.getters.getIncomingMessages(conn.sendTo, that.$store.getters.getSBD(conn.id).id).includes(conn.sendMsg)){\n                       messages.push(\"Msg: \" + conn.sendMsg)\n                  } else {\n                    messages.push(\"Msg: \")\n                    that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                  }\n               } else {\n                 messages = [\"From: \", \"Msg: \"]\n                that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                that.$store.commit('set_from_to', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id, send : \"\"})\n\n              }\n            } else{\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"actionMessage\", true);\n              messages = conn.messages\n              }\n\n            if(result.lines.length === 3){\n            let xHelper = result.lines[1].sourceX + (result.lines[2].sourceX - result.lines[1].sourceX)/2\n            let yHelper = result.lines[1].sourceY + (result.lines[2].sourceY - result.lines[1].sourceY)/2            \n            renderMessage(g, {x: xHelper, y: yHelper, type: conn.source.type, messages: messages}, false);\n            } else {  \n            renderMessage(g, {x: result.lines[2].sourceX, y: result.lines[2].sourceY, type: conn.source.type, messages: messages}, false);\n            }\n            //console.log(result.lines)\n            g.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        for (let node of document.querySelectorAll(\"#svg > g.node\")) {\n          node.remove();\n        }\n        // render nodes\n        that.nodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.nodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      let g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        1,\n        color || \"#a3a3a3\",\n        true\n      );\n      // a 5px cover to make mouse operation conveniently\n      return connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      render(g, node, isSelected);\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            let x = d3.event.dx / zoom;\n            if (currentNode.x + x < 0) {\n              x = -currentNode.x;\n            }\n            currentNode.x += x;\n            let y = d3.event.dy / zoom;\n            if (currentNode.y + y < 0) {\n              y = -currentNode.y;\n            }\n            currentNode.y += y;\n          }\n\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.nodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = uuidv4();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                    type: that.connectingInfo.source.type,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  messages: []\n                };\n                if(that.connectingInfo.source.type===\"send\"){\n                conn[\"sendTo\"] = \"\"\n                conn[\"sendMsg\"] = \"\"\n                conn[\"messages\"] = [\"To:\", \"Msg:\"]\n                } else if(that.connectingInfo.source.type===\"receive\"){\n                conn[\"receiveFrom\"] = \"\"\n                conn[\"receiveMsg\"] = \"\"\n                conn[\"messages\"] = [\"From:\", \"Msg:\"]\n                }\n                that.connections.push(conn);\n                that.$emit(\n                  \"connect\",\n                  conn,\n                  that.nodes,\n                  that.connections\n                );\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"save\", this.nodes, this.connections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.connections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.connections.splice(\n          this.connections.indexOf(connection),\n          1\n        );\n      }\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.$emit(\"delete\", node, this.nodes, this.connections);\n    },\n    removeConnection(conn) {\n      let index = this.connections.indexOf(conn);\n      this.connections.splice(index, 1);\n      this.$emit(\n        \"disconnect\",\n        conn,\n        this.nodes,\n        this.connections\n      );\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          if (node.x + x < 0) {\n            x = -node.x;\n          }\n          node.x += x;\n          if (node.y + y < 0) {\n            y = -node.y;\n          }\n          node.y += y;\n        }\n      }\n    },\n\n  },\n  mounted() {\n    this.renderNodes()\n    this.renderConnections()\n    let that = this;\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.nodes);\n            that.currentConnections.push(...that.connections);\n            event.preventDefault();\n          }\n          break;\n        case 46:\n          that.remove();\n          break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n    connections: {\n    get () {\n      return this.$store.state.nodes.find(element => element.id === this.idSBD).SBD.connections\n    },\n    set (newValue) {\n      return this.$store.dispatch('set_connections', {id : this.idSBD, connections : newValue})\n    }\n  },\n    nodes: {\n    get () {\n      return this.$store.state.nodes.find(element => element.id === this.idSBD).SBD.nodes\n    },\n    set (newValue) {\n      return this.$store.commit('set_nodes', {id : this.idSBD, nodes : newValue})\n    }\n  },\n    hoveredConnector() {\n      for (const node of this.nodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.connections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"select\", this.currentNodes);\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"selectconnection\", this.currentConnections);\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n\n  },\n};\n",{"version":3,"sources":["Flowchart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"Flowchart.vue","sourceRoot":"src/components/SBDflowchart","sourcesContent":["<template>\n\n  <div\n    id=\"chart\"\n    tabindex=\"0\"\n    :style=\"{\n    cursor: cursor,\n    }\"\n    @mousemove=\"handleChartMouseMove\"\n    @mouseup=\"handleChartMouseUp\"\n    @dblclick=\"handleChartDblClick($event)\"\n    @mousewheel=\"handleChartMouseWheel\"\n    @mousedown=\"handleChartMouseDown($event)\"\n  >\n    <span id=\"position\" class=\"unselectable\">\n      {{ cursorToChartOffset.x + \", \" + cursorToChartOffset.y }}\n    </span>\n    <svg id=\"svg\">\n      <rect class=\"selection\" height=\"0\" width=\"0\"></rect>\n    </svg>\n  </div>\n</template>\n<style src=\"./index.css\"></style>\n<script>\nimport { connect, lineTo } from \"@/utils/svg\";\nimport * as d3 from \"d3\";\nimport {\n  between,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"@/utils/math\";\nimport render from \"./render\";\nimport renderMessage from \"./renderMessage\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { mapState } from 'vuex';\n\n\nexport default {\n  name: \"flowchart\",\n  props: {\n    idSBD: {\n    type: String\n    },\n    width: {\n      type: [String, Number],\n      default: 1000,\n    },\n    height: {\n      type: [String, Number],\n      default: 1000,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  data() {\n    return {\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all connections\n       */\n      lines: [],\n    };\n  },\n\n  methods: {\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.nodes.push(node);\n      this.$emit(\"add\", node, this.nodes, this.connections);\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editnode\", node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            \n            let tempId = uuidv4()\n              let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n                type: this.connectingInfo.source.type\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              messages: [],\n            };\n            if(this.connectingInfo.source.type===\"send\"){\n            conn[\"sendTo\"] = \"\"\n            conn[\"sendMsg\"] = \"\"\n            conn[\"messages\"] = [\"To:\", \"Msg:\"]\n            } else if(this.connectingInfo.source.type===\"receive\"){\n            conn[\"receiveFrom\"] = \"\"\n            conn[\"receiveMsg\"] = \"\"\n            conn[\"messages\"] = [\"From:\", \"Msg:\"]\n            } else if(this.connectingInfo.source.type===\"action\"){\n              conn[\"actionMsg\"] = \"\"\n            }\n            this.connections.push(conn);\n            this.$emit(\n              \"connect\",\n              conn,\n              this.nodes,\n              this.connections\n            );\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        for (let element of document.querySelectorAll(\"#svg .connector\")) {\n          element.classList.add(\"active\");\n        }\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        let result = this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          destinationPosition\n        );\n      }\n    },\n    handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"dblclick\", { x: event.offsetX, y: event.offsetY });\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    getConnectorPosition(node) {\n      const halfWidth = node.width / 2;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n\n        for (let rect of document.querySelectorAll(\"#svg .selection\")) {\n          rect.classList.add(\"active\");\n          rect.setAttribute(\"x\", edge.start.x);\n          rect.setAttribute(\"y\", edge.start.y);\n          rect.setAttribute(\"width\", edge.end.x - edge.start.x);\n          rect.setAttribute(\"height\", edge.end.y - edge.start.y);\n        }\n\n        that.nodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (points.some((point) => pointRectangleIntersection(point, edge))) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.connections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        for (let element of document.querySelectorAll(\"#svg > .selection\")) {\n          element.classList.remove(\"active\");\n        }\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          for (let element of document.querySelectorAll(\n            \"#svg > g.connection\"\n          )) {\n            element.remove();\n          }\n          // render lines\n          that.lines = [];\n          for (let sendMessage of document.querySelectorAll(\"#svg > g.sendMessage\")) {\n          sendMessage.remove();}\n          for (let receiveMessage of document.querySelectorAll(\"#svg > g.receiveMessage\")) {\n          receiveMessage.remove();}\n          for (let actionMessage of document.querySelectorAll(\"#svg > g.actionMessage\")) {\n          actionMessage.remove();}\n          that.connections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position\n            );\n            let colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n              message: \"black\"\n            };\n            if (\n              that.currentConnections.filter((item) => item === conn).length > 0\n            ) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n                message: \"#52c41a\"\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              colors[\"message\"]\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n            let g = null\n            let messages = []\n            if(conn.source.type===\"receive\"){\n               g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"receiveMessage\", true);\n               if(that.$store.getters.getNode(conn.receiveFrom)){\n                  messages.push(\"From: \" + that.$store.getters.getNode(conn.receiveFrom).text)\n                  if(that.$store.getters.getOutgoingMessages(conn.receiveFrom, that.$store.getters.getSBD(conn.id).id).includes(conn.receiveMsg)){\n                  messages.push(\"Msg: \" + conn.receiveMsg)\n                  } else {\n                    messages.push(\"Msg: \")\n                  that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                  }\n               } else {\n                 messages = [\"From: \", \"Msg: \"]\n                that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                that.$store.commit('set_from_to', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id, receive : \"\"})\n               }\n            } else if(conn.source.type===\"send\"){\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"sendMessage\", true);\n               if(that.$store.getters.getNode(conn.sendTo)){\n                  messages.push(\"To: \" + that.$store.getters.getNode(conn.sendTo).text)\n                  if(that.$store.getters.getIncomingMessages(conn.sendTo, that.$store.getters.getSBD(conn.id).id).includes(conn.sendMsg)){\n                       messages.push(\"Msg: \" + conn.sendMsg)\n                  } else {\n                    messages.push(\"Msg: \")\n                    that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                  }\n               } else {\n                 messages = [\"From: \", \"Msg: \"]\n                that.$store.commit('reset_msg', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id})\n                that.$store.commit('set_from_to', {nodeID : that.$store.getters.getSBD(conn.id).id, connectionSBDID: conn.id, send : \"\"})\n\n              }\n            } else{\n              g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"actionMessage\", true);\n              messages = conn.messages\n              }\n\n            if(result.lines.length === 3){\n            let xHelper = result.lines[1].sourceX + (result.lines[2].sourceX - result.lines[1].sourceX)/2\n            let yHelper = result.lines[1].sourceY + (result.lines[2].sourceY - result.lines[1].sourceY)/2            \n            renderMessage(g, {x: xHelper, y: yHelper, type: conn.source.type, messages: messages}, false);\n            } else {  \n            renderMessage(g, {x: result.lines[2].sourceX, y: result.lines[2].sourceY, type: conn.source.type, messages: messages}, false);\n            }\n            //console.log(result.lines)\n            g.on(\"mousedown\", function (event) {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        for (let node of document.querySelectorAll(\"#svg > g.node\")) {\n          node.remove();\n        }\n        // render nodes\n        that.nodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.nodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      let g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        1,\n        color || \"#a3a3a3\",\n        true\n      );\n      // a 5px cover to make mouse operation conveniently\n      return connect(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      render(g, node, isSelected);\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            let x = d3.event.dx / zoom;\n            if (currentNode.x + x < 0) {\n              x = -currentNode.x;\n            }\n            currentNode.x += x;\n            let y = d3.event.dy / zoom;\n            if (currentNode.y + y < 0) {\n              y = -currentNode.y;\n            }\n            currentNode.y += y;\n          }\n\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.nodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          for (let element of document.querySelectorAll(\"#svg > g.guideline\")) {\n            element.remove();\n          }\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = uuidv4();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                    type: that.connectingInfo.source.type,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  messages: []\n                };\n                if(that.connectingInfo.source.type===\"send\"){\n                conn[\"sendTo\"] = \"\"\n                conn[\"sendMsg\"] = \"\"\n                conn[\"messages\"] = [\"To:\", \"Msg:\"]\n                } else if(that.connectingInfo.source.type===\"receive\"){\n                conn[\"receiveFrom\"] = \"\"\n                conn[\"receiveMsg\"] = \"\"\n                conn[\"messages\"] = [\"From:\", \"Msg:\"]\n                }\n                that.connections.push(conn);\n                that.$emit(\n                  \"connect\",\n                  conn,\n                  that.nodes,\n                  that.connections\n                );\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"save\", this.nodes, this.connections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.connections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.connections.splice(\n          this.connections.indexOf(connection),\n          1\n        );\n      }\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.$emit(\"delete\", node, this.nodes, this.connections);\n    },\n    removeConnection(conn) {\n      let index = this.connections.indexOf(conn);\n      this.connections.splice(index, 1);\n      this.$emit(\n        \"disconnect\",\n        conn,\n        this.nodes,\n        this.connections\n      );\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          if (node.x + x < 0) {\n            x = -node.x;\n          }\n          node.x += x;\n          if (node.y + y < 0) {\n            y = -node.y;\n          }\n          node.y += y;\n        }\n      }\n    },\n\n  },\n  mounted() {\n    this.renderNodes()\n    this.renderConnections()\n    let that = this;\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.nodes);\n            that.currentConnections.push(...that.connections);\n            event.preventDefault();\n          }\n          break;\n        case 46:\n          that.remove();\n          break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n    connections: {\n    get () {\n      return this.$store.state.nodes.find(element => element.id === this.idSBD).SBD.connections\n    },\n    set (newValue) {\n      return this.$store.dispatch('set_connections', {id : this.idSBD, connections : newValue})\n    }\n  },\n    nodes: {\n    get () {\n      return this.$store.state.nodes.find(element => element.id === this.idSBD).SBD.nodes\n    },\n    set (newValue) {\n      return this.$store.commit('set_nodes', {id : this.idSBD, nodes : newValue})\n    }\n  },\n    hoveredConnector() {\n      for (const node of this.nodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.connections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"select\", this.currentNodes);\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.$emit(\"selectconnection\", this.currentConnections);\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n\n  },\n};\n</script>\n"]}]}